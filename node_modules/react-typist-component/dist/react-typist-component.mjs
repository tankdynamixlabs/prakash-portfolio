import A, { Children as P, isValidElement as j, cloneElement as V, useState as B, useRef as L, useCallback as R, useEffect as F } from "react";
const v = (r) => r == null, q = (r, s) => {
  if (typeof s != "string") {
    const { children: t, ...n } = s.props;
    s.key || (n.key = "typist-cursor"), s = A.cloneElement(s, n, t);
  }
  const o = (t) => {
    if (!t)
      return t;
    if (t.length === 0)
      return [s];
    const n = t[t.length - 1];
    if (typeof n == "string")
      return [...t, s];
    const { children: c, ...u } = n.props;
    if (v(c))
      return [...t, s];
    const e = o(c), a = A.cloneElement(n, u, e);
    return [...t.slice(0, -1), a];
  };
  return o(r);
}, z = () => {
}, G = (r) => r.split(""), b = (r) => null, S = (r) => null, H = (r, s) => {
  let o = 0;
  const t = (n) => P.map(n, (u) => {
    if (o >= s.length)
      return null;
    if (j(u)) {
      if (u.type === b || u.type === S)
        return null;
      const { children: e, ...a } = u.props;
      if (v(e))
        return s[o++];
      const p = t(e);
      return p && p.length === 0 ? null : V(u, a, p);
    }
    return typeof u == "string" || typeof u == "number" ? s[o++] : null;
  });
  return t(r);
}, K = ({ children: r }) => /* @__PURE__ */ A.createElement(A.Fragment, null, r);
function J(r, s) {
  const o = [], t = [];
  let n = !1;
  const c = (u) => {
    P.forEach(u, (e) => {
      if (j(e)) {
        if (e.type === S)
          return;
        if (e.type === b) {
          let f = e.props.count;
          for (; f--; ) {
            let y = t.length - 1, E = t[y];
            for (; E === null && y > 0; )
              y -= 1, E = t[y];
            if (E === null)
              break;
            if (typeof E == "object" && (t[y] = null), typeof E == "string") {
              const w = s(E).slice(0, -1).join("");
              t[y] = w || null;
            }
            o.push([...t]);
          }
          return;
        }
        if (e.type === K) {
          n = !0, P.forEach(e.props.children, c), n = !1;
          return;
        }
        if (v(e.props.children)) {
          t.push(e), o.push([...t]);
          return;
        }
        P.forEach(e.props.children, c);
      }
      const a = (() => {
        if (typeof e == "number")
          return e.toString(10);
        if (typeof e == "string")
          return e;
      })();
      if (a === void 0)
        return;
      if (n) {
        t.push(a), o.push([...t]);
        return;
      }
      const p = s(a), l = t.length;
      for (let f = 1; f <= p.length; f++) {
        const y = p.slice(0, f).join("");
        t[l] = y, o.push([...t]);
      }
    });
  };
  return c(r), o.map((u) => H(r, u));
}
const O = (r) => ({
  type: "TYPE_TOKEN",
  payload: r
}), Q = (r) => ({
  type: "BACKSPACE",
  payload: r
}), U = (r) => ({ type: "DELAY", payload: r }), W = (r) => ({ type: "PASTE", payload: r }), X = (r, s) => {
  const o = [];
  let t = !1, n = 0;
  const c = (u) => {
    P.forEach(u, (e) => {
      if (j(e)) {
        if (e.type === b) {
          const l = e.props.count, f = l > n ? n : l;
          n -= f, o.push(Q(f));
          return;
        }
        if (e.type === S) {
          o.push(U(e.props.ms));
          return;
        }
        if (e.type === K) {
          t = !0, P.forEach(e.props.children, c), t = !1;
          return;
        }
        if (v(e.props.children)) {
          n += 1, o.push(O(e));
          return;
        }
        P.forEach(e.props.children, c);
      }
      const a = (() => {
        if (typeof e == "number")
          return e.toString(10);
        if (typeof e == "string")
          return e;
      })();
      if (a === void 0)
        return;
      if (t) {
        n += s(a).length, o.push(W(a));
        return;
      }
      const p = s(a);
      n += p.length, p.forEach((l) => {
        o.push(O(l));
      });
    });
  };
  return c(r), o;
}, Z = ({
  cursor: r,
  disabled: s = !1,
  restartKey: o,
  children: t,
  splitter: n = G,
  typingDelay: c = 75,
  backspaceDelay: u = c,
  onTypingDone: e,
  startDelay: a = 0,
  finishDelay: p = 0,
  loop: l = !1,
  pause: f = !1
}) => {
  const [y, E] = B([]), [N, w] = B(-1), k = L(z), C = L(l), x = L(f), h = R((m) => new Promise((g, i) => {
    const T = typeof m == "number" ? m : m(), I = setTimeout(g, T);
    k.current = () => {
      clearTimeout(I), i();
    };
  }), []), _ = R(() => new Promise((m, g) => {
    const i = setInterval(() => {
      x.current || (clearInterval(i), m());
    });
    k.current = () => {
      clearInterval(i), g();
    };
  }), []), d = R(() => new Promise((m, g) => {
    const i = setInterval(() => {
      C.current && (clearInterval(i), m());
    });
    k.current = () => {
      clearInterval(i), g();
    };
  }), []);
  F(() => {
    C.current = l, x.current = f;
  }, [l, f]), F(() => {
    const m = J(t, n);
    if (E(m), s) {
      w(m.length - 1);
      return;
    }
    return (async () => {
      try {
        do {
          w(-1);
          const g = X(t, n);
          a > 0 && await h(a);
          for (const { type: i, payload: T } of g)
            if (x.current && await _(), i === "TYPE_TOKEN")
              w((I) => I + 1), await h(c);
            else if (i === "BACKSPACE") {
              let I = T;
              for (; I--; )
                w((M) => M + 1), await h(u);
            } else
              i === "PASTE" ? w((I) => I + 1) : i === "DELAY" && await h(T);
          e == null || e(), p > 0 && await h(p), C.current || await d();
        } while (C.current);
      } catch {
      }
    })(), () => {
      k.current();
    };
  }, [o, s]);
  const Y = y[N];
  return /* @__PURE__ */ A.createElement(A.Fragment, null, r ? q(Y, r) : Y);
}, D = Object.assign(Z, { Delay: S, Backspace: b, Paste: K });
export {
  D as default
};
